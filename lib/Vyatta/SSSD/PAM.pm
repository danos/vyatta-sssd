# Copyright (c) 2019 AT&T intellectual property.
# All rights reserved.
#
# Copyright (c) 2014, 2017 Brocade Communications Systems, Inc.
# All rights reserved.
#
# SPDX-License-Identifier: LGPL-2.1-only

package Vyatta::SSSD::PAM;

use warnings;
use strict;

use lib "/opt/vyatta/share/perl5";

use Vyatta::Config;
use Vyatta::SSSD::Local;
use Authen::PAM qw( :constants );

use Exporter q{import};
our @EXPORT = qw( setup_pam_for_service pam_validate_user );

my $SERVICE_PREFIX = "vyatta-";


sub setup_local_domain {
    my ($config_space, $service_instance) = @_;

    my $config = new Vyatta::Config;

    # For each service instance, one internal group gets created.
    # This internal group name must start with vyatta- and will be not
    # disabled inside the CLI.
    my $service_group = $service_instance;
    add_group($service_group);

    # Handle service-user users
    $config->setLevel($config_space." local user");
    foreach my $user ( $config->returnValues() ) {
       user_add_group($user, $service_group);
    }

    foreach my $user ( local_users() ) {
       next if $config->exists("$user");
       user_remove_group($user, $service_group);
    }

    # Handle service-user groups
    $config->setLevel($config_space." local group");
    foreach my $group_member ( $config->returnValues() ) {
       groupmod_append_group($group_member, $service_group);
    }

    foreach my $group_member ( list_sssd_group_member_groups($service_group) ) {
       next if $config->exists("$group_member");
       groupmod_remove_group($group_member, $service_group);
    }
}

sub generate_pam {
    my ($config_space, $service_instance) = @_;

    my $service_user_domains = undef;
    my $pam_sss_service_users = "";
    my $pam_sss_service_users_local = "";

    my $config = new Vyatta::Config;
    $config->setLevel($config_space);
    my @auth_methods = $config->listNodes();

    foreach my $auth_method ( @auth_methods ) {
         next if ($auth_method eq 'local');

         foreach my $domain ( $config->returnValues($auth_method) ) {
            if (defined($service_user_domains)) {
               $service_user_domains = $service_user_domains . ',';
            }
            $service_user_domains = $service_user_domains . $domain;
         }
    }


    if (defined($service_user_domains)) {
       $pam_sss_service_users = "
auth sufficient pam_sss.so domains=$service_user_domains
account sufficient pam_sss.so domains=$service_user_domains
";
    }

    if (grep { $_ eq 'local' } @auth_methods) {
       $pam_sss_service_users_local = "
auth sufficient pam_sss.so domains=local
account required pam_sss.so domains=local
account sufficient pam_succeed_if.so user ingroup $service_instance
";
    }

    my $content = "##
## This file is auto-generated by Vyatta:SSSD:PAM.pm.
## Do not edit, all changes will be lost!
##

$pam_sss_service_users
$pam_sss_service_users_local

auth requisite pam_deny.so
account requisite pam_deny.so
";

    my $path = "/etc/pam.d/".$service_instance.".conf";
    open(my $fd, '>', $path)
         or die "Can't generate authentication configuration! Can't open file $path: $!";
    print $fd $content;
    close $fd;
}

sub setup_pam_for_service {
    my ($config_space, $service, $instance) = @_;

    my $service_instance = $SERVICE_PREFIX . $service ."-". $instance;

    my $config = new Vyatta::Config;
    $config->setLevel($config_space);
    my @auth_methods = $config->listNodes();

    setup_local_domain($config_space, $service_instance)
       if (grep { $_ eq 'local' } @auth_methods);

    generate_pam($config_space, $service_instance);
}

#
# pam_validate_user verifies via PAM if a user exists in a configured PAM service
# configuration. This allows to check if service PAM configuration would grant a
# user XYZ access, by checking LDAP domains, local domain or other SSSD domains which
# are configured in that specific PAM service configuration.
#
# Known issues:
#  - LDAP domains: search-filter gets ignored. Only base-dn gets matchted. This results
#                  in more matches then actually wanted. (E.g. users which would be
#                  excluded by the search-filter)
# - LOCAL domains: pam accgt_mgmt require pam conversation / authentication and fails with
#                  PAM_AUTH_ERR. This is still good enough to indicate that this user
#                  would be granted access to the particular service interface.
#
sub pam_validate_user {
        my ($service, $instance, $user) = @_;

        die "User is required for PAM validation" unless($user);

        my $pam_service = $SERVICE_PREFIX . $service ."-". $instance .".conf";
        my $pam = Authen::PAM->new( $pam_service, $user );
        die "PAM verification failed while preparing PAM handle" unless($pam);

        return undef unless -e "/etc/pam.d/$pam_service";

        my $result = $pam->pam_acct_mgmt;

	# PAM_AUTH_ERR is also an indication for SSSD and pam_sss that a user
	# exists. PAM_AUTH_ERR get returned if a local domain users exists.
	# The PAM_AUTH_ERR is due to authentication attempts with pam conversation,
	# which fails since no pam conversion handler is set.
        return 1 if ($result == PAM_SUCCESS || $result == PAM_AUTH_ERR);
        return undef;
}

1;
